<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>.NET on 隨筆</title>
    <link>https://harveyChang67.github.io/categories/.net/</link>
    <description>Recent content in .NET on 隨筆</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 30 Sep 2022 02:40:01 +0000</lastBuildDate><atom:link href="https://harveyChang67.github.io/categories/.net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dotnet_parallel</title>
      <link>https://harveyChang67.github.io/posts/dotnet_parallel/</link>
      <pubDate>Fri, 30 Sep 2022 02:40:01 +0000</pubDate>
      
      <guid>https://harveyChang67.github.io/posts/dotnet_parallel/</guid>
      <description>一個 Batch Task 遇到一段 Code， SQL.Select in a for-loop that runs 25k times 特別是 for-loop 內 以 await 去使用了 async 的 DB Layer Func.
我請團隊在 Parallel 的修改版本加上限制。
var parallel = new ParallelOptions { MaxDegreeOfParallelism = 5 }; 也與另一個做法 Task.Run, Task.WhenAll 進一步區隔。
 ref:
 Running Async Foreach Loop C# async await Parallel.ForEach vs Task.Run and Task.WhenAll https://gitter.im/npgsql/npgsql?at=595a0319c101bc4e3a46654d   系統式思考 這個課題在團隊內的討論很有趣， 討論過程中對於可能的問題不乏 AP Logic 有問題、SQL 有問題、&amp;hellip;， 但卻不太動手實測每段時間。
那段邏輯在開發環境中執行一個 SQL SELECT Query 約 2ms， 但 For Loop 高達 3萬筆資料， 在 不修改 AP 主 Logic &amp;amp; SQL 的前提下可發揮的空間有限（數位轉型日常，除非先完成驗證過結果正確）， 因此團隊將 部分邏輯 改為 Parallel 是可以進行嘗試的。 （前提是該 AP Logic 不會因此修改造成 髒資料）</description>
    </item>
    
    <item>
      <title>RepoDB_C#</title>
      <link>https://harveyChang67.github.io/posts/repodb_c#/</link>
      <pubDate>Wed, 27 Apr 2022 11:21:06 +0000</pubDate>
      
      <guid>https://harveyChang67.github.io/posts/repodb_c#/</guid>
      <description>RepoDB 在 Generic Repository Pattern 中很好用， 免去使用 Dapper 去自建 SQL 產生器， 但是有幾個限制 RepoDB Limitations， 其中一個令人訝異 -&amp;gt; Composite Keys。
Composite Keys RepoDB 只會處理 1 個 Primary Key&amp;hellip;. 這邊紀錄兩個相關的資訊
Update + condition termsList.Add( new QueryField(&amp;#39;Id&amp;#39;, Operation.Equal, &amp;#39;10095&amp;#39;) ); termsList.Add( new QueryField(&amp;#39;Name&amp;#39;, Operation.Equal, &amp;#39;John&amp;#39;) ); ret = dbConn.Update(entity, new QueryGroup(termsList, Conjunction.And)); Primary Properties Model 中標註 Mapping，
public class FMRMUSRT { [Primary] // Primary decoration  public string Id { get; set; } [Primary] // Primary decoration  public string item_cd { get; set; } public string?</description>
    </item>
    
  </channel>
</rss>
