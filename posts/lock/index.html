<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lock | 隨筆</title><meta name=keywords content><meta name=description content="單機鎖 TODO
分布式鎖 相關  單機鎖&ndash;>分布式鎖：架構面試題 #1, 線上交易的正確性 將 Redlock 有關的問題整理清楚：  如何做可靠的分布式锁，Redlock真的可行么 https://twgreatdaily.com/fGfHe28BMH2_cNUgKj2O.html     概念 悲觀鎖（Pessimistic Lock） 預期每次都會遇到資源爭奪。
共享鎖（Share Lock） 排他鎖（Exclusive Lock）
作用範圍：
  行鎖（row lock） FOR UPDATE、FOR UPDATE NO KEY、LOCK IN SHARE MODE
  表鎖（table lock）
SELECT SUM(..) FROM ..   樂觀鎖（Optimistic Lock） Optimistic Concurrency Control 每次存取都認為不會有別人來搶。
CAS（比較與交換，Compare and swap）
 非阻塞同步（Non-blocking Synchronization）、無鎖程式設計演算法（ Non-blocking algorithm）
 適合：讀多寫少。 反之，將有很多的寫衝突造成等待
 CAS有3個運算元  記憶體值V 舊的預期值A 要修改的新值B 當且僅當預期值A和記憶體值V相同時，將記憶體值V修改為B，否則什麼都不做。   整個CAS操作是一個原子操作 判斷作法  TimeStamp Version 待更新欄位：更新前可以拿要更新的欄位的舊值和資料庫的現值進行比對，沒有變化則更新  https://stackoverflow."><meta name=author content><link rel=canonical href=https://harveyChang67.github.io/posts/lock/><link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://harveyChang67.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://harveyChang67.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://harveyChang67.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://harveyChang67.github.io/apple-touch-icon.png><link rel=mask-icon href=https://harveyChang67.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-88L9K87ZCW"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-88L9K87ZCW',{anonymize_ip:!1})}</script><meta property="og:title" content="Lock"><meta property="og:description" content="單機鎖 TODO
分布式鎖 相關  單機鎖&ndash;>分布式鎖：架構面試題 #1, 線上交易的正確性 將 Redlock 有關的問題整理清楚：  如何做可靠的分布式锁，Redlock真的可行么 https://twgreatdaily.com/fGfHe28BMH2_cNUgKj2O.html     概念 悲觀鎖（Pessimistic Lock） 預期每次都會遇到資源爭奪。
共享鎖（Share Lock） 排他鎖（Exclusive Lock）
作用範圍：
  行鎖（row lock） FOR UPDATE、FOR UPDATE NO KEY、LOCK IN SHARE MODE
  表鎖（table lock）
SELECT SUM(..) FROM ..   樂觀鎖（Optimistic Lock） Optimistic Concurrency Control 每次存取都認為不會有別人來搶。
CAS（比較與交換，Compare and swap）
 非阻塞同步（Non-blocking Synchronization）、無鎖程式設計演算法（ Non-blocking algorithm）
 適合：讀多寫少。 反之，將有很多的寫衝突造成等待
 CAS有3個運算元  記憶體值V 舊的預期值A 要修改的新值B 當且僅當預期值A和記憶體值V相同時，將記憶體值V修改為B，否則什麼都不做。   整個CAS操作是一個原子操作 判斷作法  TimeStamp Version 待更新欄位：更新前可以拿要更新的欄位的舊值和資料庫的現值進行比對，沒有變化則更新  https://stackoverflow."><meta property="og:type" content="article"><meta property="og:url" content="https://harveyChang67.github.io/posts/lock/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-27T06:14:32+00:00"><meta property="article:modified_time" content="2022-01-27T06:14:32+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lock"><meta name=twitter:description content="單機鎖 TODO
分布式鎖 相關  單機鎖&ndash;>分布式鎖：架構面試題 #1, 線上交易的正確性 將 Redlock 有關的問題整理清楚：  如何做可靠的分布式锁，Redlock真的可行么 https://twgreatdaily.com/fGfHe28BMH2_cNUgKj2O.html     概念 悲觀鎖（Pessimistic Lock） 預期每次都會遇到資源爭奪。
共享鎖（Share Lock） 排他鎖（Exclusive Lock）
作用範圍：
  行鎖（row lock） FOR UPDATE、FOR UPDATE NO KEY、LOCK IN SHARE MODE
  表鎖（table lock）
SELECT SUM(..) FROM ..   樂觀鎖（Optimistic Lock） Optimistic Concurrency Control 每次存取都認為不會有別人來搶。
CAS（比較與交換，Compare and swap）
 非阻塞同步（Non-blocking Synchronization）、無鎖程式設計演算法（ Non-blocking algorithm）
 適合：讀多寫少。 反之，將有很多的寫衝突造成等待
 CAS有3個運算元  記憶體值V 舊的預期值A 要修改的新值B 當且僅當預期值A和記憶體值V相同時，將記憶體值V修改為B，否則什麼都不做。   整個CAS操作是一個原子操作 判斷作法  TimeStamp Version 待更新欄位：更新前可以拿要更新的欄位的舊值和資料庫的現值進行比對，沒有變化則更新  https://stackoverflow."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://harveyChang67.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Lock","item":"https://harveyChang67.github.io/posts/lock/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lock","name":"Lock","description":"單機鎖 TODO\n分布式鎖 相關  單機鎖\u0026ndash;\u0026gt;分布式鎖：架構面試題 #1, 線上交易的正確性 將 Redlock 有關的問題整理清楚：  如何做可靠的分布式锁，Redlock真的可行么 https://twgreatdaily.com/fGfHe28BMH2_cNUgKj2O.html     概念 悲觀鎖（Pessimistic Lock） 預期每次都會遇到資源爭奪。\n共享鎖（Share Lock） 排他鎖（Exclusive Lock）\n作用範圍：\n  行鎖（row lock） FOR UPDATE、FOR UPDATE NO KEY、LOCK IN SHARE MODE\n  表鎖（table lock）\nSELECT SUM(..) FROM ..   樂觀鎖（Optimistic Lock） Optimistic Concurrency Control 每次存取都認為不會有別人來搶。\nCAS（比較與交換，Compare and swap）\n 非阻塞同步（Non-blocking Synchronization）、無鎖程式設計演算法（ Non-blocking algorithm）\n 適合：讀多寫少。 反之，將有很多的寫衝突造成等待\n CAS有3個運算元  記憶體值V 舊的預期值A 要修改的新值B 當且僅當預期值A和記憶體值V相同時，將記憶體值V修改為B，否則什麼都不做。   整個CAS操作是一個原子操作 判斷作法  TimeStamp Version 待更新欄位：更新前可以拿要更新的欄位的舊值和資料庫的現值進行比對，沒有變化則更新  https://stackoverflow.","keywords":[],"articleBody":"單機鎖 TODO\n分布式鎖 相關  單機鎖–分布式鎖：架構面試題 #1, 線上交易的正確性 將 Redlock 有關的問題整理清楚：  如何做可靠的分布式锁，Redlock真的可行么 https://twgreatdaily.com/fGfHe28BMH2_cNUgKj2O.html     概念 悲觀鎖（Pessimistic Lock） 預期每次都會遇到資源爭奪。\n共享鎖（Share Lock） 排他鎖（Exclusive Lock）\n作用範圍：\n  行鎖（row lock） FOR UPDATE、FOR UPDATE NO KEY、LOCK IN SHARE MODE\n  表鎖（table lock）\nSELECT SUM(..) FROM ..   樂觀鎖（Optimistic Lock） Optimistic Concurrency Control 每次存取都認為不會有別人來搶。\nCAS（比較與交換，Compare and swap）\n 非阻塞同步（Non-blocking Synchronization）、無鎖程式設計演算法（ Non-blocking algorithm）\n 適合：讀多寫少。 反之，將有很多的寫衝突造成等待\n CAS有3個運算元  記憶體值V 舊的預期值A 要修改的新值B 當且僅當預期值A和記憶體值V相同時，將記憶體值V修改為B，否則什麼都不做。   整個CAS操作是一個原子操作 判斷作法  TimeStamp Version 待更新欄位：更新前可以拿要更新的欄位的舊值和資料庫的現值進行比對，沒有變化則更新  https://stackoverflow.com/a/62959208   所有欄位：相當於表鎖    implement Entity Framework Core\n https://docs.microsoft.com/zh-tw/ef/core/saving/concurrency  延伸、變通  Apache Ignite 避免 Deadlock 類似 MVCC… Oracle 9i… PostgreSQL Redis 內部也有 lock optimistic locking in REST API  https://linuxtut.com/en/c4585a2373c15d84c1d9/ https://blog.appsignal.com/2021/10/20/optimistic-locking-in-rails-rest-apis.html https://sookocheff.com/post/api/optimistic-locking-in-a-rest-api/   分布鎖  https://liulixiang1988.github.io/2021/08/13/2021-08-13-DistributedLockManager/    ","wordCount":"92","inLanguage":"en","datePublished":"2022-01-27T06:14:32Z","dateModified":"2022-01-27T06:14:32Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://harveyChang67.github.io/posts/lock/"},"publisher":{"@type":"Organization","name":"隨筆","logo":{"@type":"ImageObject","url":"https://harveyChang67.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://harveyChang67.github.io/ accesskey=h title="隨筆 (Alt + H)">隨筆</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://harveyChang67.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://harveyChang67.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Lock</h1><div class=post-meta>January 27, 2022</div></header><div class=post-content><h2 id=單機鎖>單機鎖<a hidden class=anchor aria-hidden=true href=#單機鎖>#</a></h2><p><code>TODO</code></p><h2 id=分布式鎖-相關>分布式鎖 相關<a hidden class=anchor aria-hidden=true href=#分布式鎖-相關>#</a></h2><ul><li>單機鎖&ndash;>分布式鎖：<a href=https://columns.chicken-house.net/2018/03/25/interview01-transaction/>架構面試題 #1, 線上交易的正確性</a></li><li>將 Redlock 有關的問題整理清楚：<ul><li><a href=https://github.com/ChangAn223/Python-Interview/blob/master/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E5%A6%82%E4%BD%95%E5%81%9A%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%8CRedlock%E7%9C%9F%E7%9A%84%E5%8F%AF%E8%A1%8C%E4%B9%88.md>如何做可靠的分布式锁，Redlock真的可行么</a></li><li><a href=https://twgreatdaily.com/fGfHe28BMH2_cNUgKj2O.html>https://twgreatdaily.com/fGfHe28BMH2_cNUgKj2O.html</a></li></ul></li></ul><hr><h2 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h2><h3 id=悲觀鎖pessimistic-lock>悲觀鎖（Pessimistic Lock）<a hidden class=anchor aria-hidden=true href=#悲觀鎖pessimistic-lock>#</a></h3><p><code>預期每次都會遇到資源爭奪。</code></p><p>共享鎖（Share Lock）
排他鎖（Exclusive Lock）</p><p>作用範圍：</p><ul><li><p>行鎖（row lock）
FOR UPDATE、FOR UPDATE NO KEY、LOCK IN SHARE MODE</p></li><li><p>表鎖（table lock）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>SUM</span>(..) <span style=color:#66d9ef>FROM</span> ..
</code></pre></div></li></ul><h3 id=樂觀鎖optimistic-lock>樂觀鎖（Optimistic Lock）<a hidden class=anchor aria-hidden=true href=#樂觀鎖optimistic-lock>#</a></h3><p>Optimistic Concurrency Control
<code>每次存取都認為不會有別人來搶。</code></p><p>CAS（比較與交換，Compare and swap）</p><blockquote><p>非阻塞同步（Non-blocking Synchronization）、無鎖程式設計演算法（ Non-blocking algorithm）</p></blockquote><p>適合：讀多寫少。
反之，將有很多的寫衝突造成等待</p><ul><li>CAS有3個運算元<ul><li>記憶體值V</li><li>舊的預期值A</li><li>要修改的新值B
當且僅當預期值A和記憶體值V相同時，將記憶體值V修改為B，否則什麼都不做。</li></ul></li><li>整個CAS操作是一個原子操作</li><li>判斷作法<ul><li>TimeStamp</li><li>Version</li><li>待更新欄位：更新前可以拿要更新的欄位的舊值和資料庫的現值進行比對，沒有變化則更新<ul><li><a href=https://stackoverflow.com/a/62959208>https://stackoverflow.com/a/62959208</a></li></ul></li><li>所有欄位：相當於表鎖</li></ul></li></ul><h4 id=implement>implement<a hidden class=anchor aria-hidden=true href=#implement>#</a></h4><p>Entity Framework Core</p><ul><li><a href=https://docs.microsoft.com/zh-tw/ef/core/saving/concurrency>https://docs.microsoft.com/zh-tw/ef/core/saving/concurrency</a></li></ul><h2 id=延伸變通>延伸、變通<a hidden class=anchor aria-hidden=true href=#延伸變通>#</a></h2><ul><li>Apache Ignite 避免 Deadlock 類似 MVCC&mldr; Oracle 9i&mldr; PostgreSQL</li><li>Redis 內部也有 lock</li><li>optimistic locking in REST API<ul><li><a href=https://linuxtut.com/en/c4585a2373c15d84c1d9/>https://linuxtut.com/en/c4585a2373c15d84c1d9/</a></li><li><a href=https://blog.appsignal.com/2021/10/20/optimistic-locking-in-rails-rest-apis.html>https://blog.appsignal.com/2021/10/20/optimistic-locking-in-rails-rest-apis.html</a></li><li><a href=https://sookocheff.com/post/api/optimistic-locking-in-a-rest-api/>https://sookocheff.com/post/api/optimistic-locking-in-a-rest-api/</a></li></ul></li><li>分布鎖<ul><li><a href=https://liulixiang1988.github.io/2021/08/13/2021-08-13-DistributedLockManager/>https://liulixiang1988.github.io/2021/08/13/2021-08-13-DistributedLockManager/</a></li></ul></li></ul></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://harveyChang67.github.io/>隨筆</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>